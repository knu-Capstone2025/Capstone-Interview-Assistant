@page "/"
@using InterviewAssistant.Common.Models
@using InterviewAssistant.Web.Services
@using Markdig
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components.Web
@using System.Linq
@inject IChatService ChatService
@inject IReportService ReportService
@inject IJSRuntime JSRuntime
@inject ILogger<Home> Logger
@rendermode InteractiveServer

<PageTitle>면접 코치 - InterviewAssistant</PageTitle>

<!-- 모달 창 영역 -->
@if (showModal)
{
    <div class="modal show">
        <div class="modal-overlay" @onclick="CloseModal"></div>
        <div class="modal-container">
            <div class="modal-header">
                <h3>링크 공유</h3>
                <button class="close-btn" @onclick="CloseModal">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="resumeUrl">이력서 URL</label>
                    <input type="text" id="resumeUrl" @bind="resumeUrl" placeholder="이력서 URL을 입력하세요" />
                </div>
                <div class="form-group">
                    <label for="jobUrl">채용공고 URL</label>
                    <input type="text" id="jobUrl" @bind="jobUrl" placeholder="채용공고 URL을 입력하세요" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel-btn" @onclick="CloseModal">취소</button>
                <button class="submit-btn" @onclick="SubmitLinks">확인</button>
            </div>
        </div>
    </div>
}

<!-- 메인 채팅 영역 -->
<div class="chat-main">
    <!-- 채팅 메시지 영역 -->
    <div class="chat-messages" id="chatMessages">
        @if (!isLinkShared)
        {
            <div class="welcome-message">
                <h2>면접 코치 봇에 오신 것을 환영합니다!</h2>
                <p>질문을 입력하시면 면접 준비를 도와드립니다.</p>
                <button class="share-btn" @onclick="() => showModal = true">
                    <i class="share-icon"></i>
                    이력서 및 채용공고 공유하기
                </button>
            </div>
        }
        else
        {
            @foreach (var message in messages)
            {
                <div class="message @(message.Role == MessageRoleType.User ? "user-message" : "bot-message")">
                    <div class="message-content">
                        @((MarkupString)Markdown.ToHtml(message.Message).Trim())
                    </div>
                </div>
            }

            <!-- 종합 피드백 완료 시 PDF 다운로드 버튼 -->
            @if (isInterviewCompleted)
            {
                <div class="interview-completed-section">
                    <h3>🎉 면접이 완료되었습니다!</h3>
                    <p>종합 피드백이 완료되어 면접 리포트를 다운로드할 수 있습니다.</p>
                    <button class="pdf-download-btn" @onclick="DownloadPdfReport" disabled="@isGeneratingPdf">
                        @if (isGeneratingPdf)
                        {
                            <span>📄 PDF 생성 중...</span>
                        }
                        else
                        {
                            <span>📄 면접 리포트 PDF 다운로드</span>
                        }
                    </button>
                </div>
            }
        }
        @if (isLoading)
        {
            <div class="message bot-message">
                <div class="message-content">
                    <div class="loading-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>
        }
    </div>

    <!-- 입력 영역 -->
    <div class="chat-input-container">
        <div class="input-wrapper">
            <textarea 
                id="messageInput"
                @bind="userInput" 
                @bind:event="oninput" 
                @onkeydown="HandleKeyDown" 
                placeholder="메시지를 입력하세요." 
                rows="1"
                disabled="@(isLoading || !isLinkShared)"></textarea>
            <button class="send-btn" @onclick="SendMessage" disabled="@IsReadyToSendMessage()">
                <span class="send-icon">↵</span>
            </button>
        </div>
        @if (!isServerOutputEnded)
        {
            <div class="response-status">
                <small>서버 응답 출력 중... 출력이 완료될 때까지 기다려주세요.</small>
            </div>
        }
    </div>
</div>

@code {
    private List<ChatMessage> messages = new List<ChatMessage>();
    private string userInput = string.Empty;
    private bool isLoading = false;
    // 링크 공유 여부
    private bool isLinkShared = false;
    private bool isServerOutputEnded = true;
    // 메시지 전송 중 여부
    private bool isSend = false;
    // 모달 관련 변수
    private bool showModal = false;
    private string resumeUrl = string.Empty;
    private string jobUrl = string.Empty;
    // 저장된 ID 변수
    private Guid currentResumeId;
    private Guid currentJobDescriptionId;
    // PDF 관련 변수
    private bool isInterviewCompleted = false;
    private bool isGeneratingPdf = false;
    private List<QuestionAnswer> questionsAndAnswers = new();
    private string finalFeedback = string.Empty;
    
    private void CloseModal() => showModal = false;

    //Blazor 컴포넌트가 처음 초기화될 때 자동으로 호출
    protected override async Task OnInitializedAsync()
    {
        // 최초 렌더링 시 GUID 생성
        currentResumeId = Guid.NewGuid();
        currentJobDescriptionId = Guid.NewGuid();
        
        // 초기화 작업이 완료되었음을 명시
        await Task.CompletedTask;
    }

    bool IsValidUrl(string url)
    {
        return Uri.TryCreate(url, UriKind.Absolute, out Uri? uri) && 
            (uri.Scheme == Uri.UriSchemeHttp || uri.Scheme == Uri.UriSchemeHttps);
    }

    private async Task SubmitLinks()
    {
        // URL 검증
        if (!string.IsNullOrWhiteSpace(resumeUrl) && !string.IsNullOrWhiteSpace(jobUrl) &&
            IsValidUrl(resumeUrl) && IsValidUrl(jobUrl))
        {
            CloseModal();
            isLinkShared = true;

            // URL 정제
            var request = new InterviewDataRequest
            {
                //이후 GUID 생성
                ResumeUrl = resumeUrl,
                JobDescriptionUrl = jobUrl,
                ResumeId = currentResumeId,
                JobDescriptionId = currentJobDescriptionId
            };

            isLoading = true;
            isServerOutputEnded = false;
            StateHasChanged();
            
            var assistantMessage = new ChatMessage 
            { 
                Role = MessageRoleType.Assistant, 
                Message = string.Empty 
            };

            var responses = ChatService.SendInterviewDataAsync(request);
            bool first = true;

            try
            {
                await foreach (var response in responses)
                {
                    if (first)
                    {
                        first = false;
                        messages.Add(assistantMessage);

                        isLoading = false;
                        StateHasChanged();
                        await JSRuntime.InvokeVoidAsync("resetAutoScroll");
                        await JSRuntime.InvokeVoidAsync("forceScrollToBottom", "chatMessages");
                    }
                    assistantMessage.Message += response.Message;
                    await ScrollToBottom();
                    StateHasChanged();
                }
            }
            catch (Exception ex)
            {
                messages.Add(new ChatMessage { Role = MessageRoleType.Assistant, Message = $"오류: {ex.Message}" });
            }
            finally
            {
                isServerOutputEnded = true;
                isLoading = false;
                StateHasChanged();
            }
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("alert", "URL이 유효하지 않습니다. 다시 확인해주세요.");
        }
    }

    // 키 입력 처리 (엔터키로 메시지 전송)
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Repeat || isSend) return;
        
        isSend = true;
        
        try
        {
            if (e.Key == "Enter" && !e.ShiftKey)
            {
                var actualValue = await JSRuntime.InvokeAsync<string>("getTextAreaValue", "messageInput");
                
                if (!string.IsNullOrWhiteSpace(actualValue))
                {
                    userInput = actualValue.TrimEnd('\n', '\r');
                    await SendMessage();
                }
            }
        }
        finally
        {
            isSend = false;
        }
    }
    // 메시지 전송 - 서비스 사용
    private async Task SendMessage()
    {
        if (IsReadyToSendMessage())
        {
            return;
        }

        // GUID 로깅
        Logger.LogInformation($"Sending message with Resume ID: {currentResumeId}");
        Logger.LogInformation($"Sending message with Job Description ID: {currentJobDescriptionId}");
        Logger.LogInformation($"Resume URL being used: {resumeUrl}");
        Logger.LogInformation($"Job URL being used: {jobUrl}");        
        // GUID가 이미 생성되어 있는지 확인
        if (currentResumeId == Guid.Empty || currentJobDescriptionId == Guid.Empty)
        {
            Logger.LogWarning("Missing GUIDs detected, creating new ones");
            currentResumeId = Guid.NewGuid();
            currentJobDescriptionId = Guid.NewGuid();
        }

        var userMessage = new ChatMessage { Role = MessageRoleType.User, Message = userInput };
        messages.Add(userMessage);

        await JSRuntime.InvokeVoidAsync("resetAutoScroll");
        userInput = string.Empty;

        await ScrollToBottom();

        try
        {
            isLoading = true;
            isServerOutputEnded = false; // 서버 응답이 시작됨을 표시
            StateHasChanged();
            await JSRuntime.InvokeVoidAsync("forceScrollToBottom", "chatMessages");

            // ChatService를 통해 응답 가져오기
            var responses = ChatService.SendMessageAsync(messages, resumeId: currentResumeId, jobDescriptionId: currentJobDescriptionId);

            var assistantMessage = new ChatMessage { Role = MessageRoleType.Assistant, Message = string.Empty };
            messages.Add(assistantMessage);

            bool first = true;
            await foreach (var response in responses)
            {    
                if (first)
                {
                    isLoading = false;
                    first = false;
                    StateHasChanged(); // 첫 문자 등자 등장하면 로딩 끄고 UI 갱신

                    // 첫 응답 도착 시 무조건 맨 아래로 스크롤
                    await JSRuntime.InvokeVoidAsync("resetAutoScroll");
                    await JSRuntime.InvokeVoidAsync("forceScrollToBottom", "chatMessages");
                }
                
                // 점진적으로 메시지를 추가하면서 렌더링
                assistantMessage.Message += response.Message;
                await ScrollToBottom();
                StateHasChanged();
            }
            
            // 응답이 완전히 끝난 후 면접 완료 감지
            CheckIfInterviewCompleted(assistantMessage.Message);
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage { Role = MessageRoleType.Assistant, Message = $"오류가 발생했습니다: {ex.Message}" });
            Logger.LogError(ex, "메시지 전송 중 오류 발생");
        }
        finally
        {
            isServerOutputEnded = true; // 서버 응답이 끝났음을 표시
            StateHasChanged();
            await ScrollToBottom();
            await JSRuntime.InvokeVoidAsync("resetTextAreaHeight", "messageInput");
            await JSRuntime.InvokeVoidAsync("focusTextArea", "messageInput");
        }
    }

    private bool IsReadyToSendMessage()
    {
        return string.IsNullOrWhiteSpace(userInput) || isLoading || !isServerOutputEnded;
    }

    // 채팅창 스크롤을 항상 최하단으로
    private async Task ScrollToBottom()
    {
        await Task.Delay(50); // 렌더링 시간 고려
        await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatMessages");
    }

    // 페이지로드시 자동으로 리사이징
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // 처음 렌더링될 때만 설정
            await JSRuntime.InvokeVoidAsync("setupTextAreaResize", "messageInput");
            await JSRuntime.InvokeVoidAsync("setupAutoScrollDetection", "chatMessages");
            // await JSRuntime.InvokeVoidAsync("initScrollButton", "chatMessages");
            
            try
            {
                // 먼저 DotNet 객체가 사용 가능한지 확인
                await JSRuntime.InvokeVoidAsync("eval", @"
                    if (typeof window.DotNet === 'undefined' || !window.DotNet.invokeMethodAsync) {
                        console.warn('DotNet interop not ready');
                    } else {
                        console.log('DotNet interop is ready');
                    }
                ");
                
                // 잠시 대기 후 컴포넌트 등록
                await Task.Delay(200);
                
                // 테스트용으로 컴포넌트 인스턴스를 전역에 등록
                await JSRuntime.InvokeVoidAsync("eval", "window.homeComponent = arguments[0];", DotNetObjectReference.Create(this));
                
                // Global component assignment 함수도 정의
                await JSRuntime.InvokeVoidAsync("eval", @"
                    window.assignGlobalComponent = function(component) {
                        window.globalComponent = component;
                        console.log('Global component assigned');
                    };
                ");
            }
            catch (Exception ex)
            {
                // JavaScript interop 실패 시 무시 (테스트 중)
                System.Diagnostics.Debug.WriteLine($"JavaScript interop setup failed: {ex.Message}");
            }
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    // 종합 피드백 완료 감지 로직
    private void CheckIfInterviewCompleted(string message)
    {
        // 종합 피드백 완료 감지 키워드 (더 정확하게)
        var feedbackCompletionKeywords = new[]
        {
            "종합 피드백",
            "전반적인 평가", 
            "면접을 마치겠습니다",
            "최종 평가",
            "총평을 드리겠습니다",
            "종합적으로 평가",
            "면접 결과",
            "피드백을 종합하면"
        };

        // 종합 피드백이 완료되었는지 확인 (메시지 길이도 고려)
        if (!isInterviewCompleted && 
            feedbackCompletionKeywords.Any(keyword => message.Contains(keyword)) &&
            message.Length > 100) // 종합 피드백은 보통 긴 메시지
        {
            isInterviewCompleted = true;
            finalFeedback = message;
            ExtractQuestionsAndAnswers();
            Logger.LogInformation("종합 피드백 완료 감지됨!");
            StateHasChanged();
        }
    }

    // 질문과 답변 추출 (개선된 버전)
    private void ExtractQuestionsAndAnswers()
    {
        questionsAndAnswers.Clear();
        
        // 사용자 메시지와 AI 응답을 매칭
        for (int i = 1; i < messages.Count; i++)
        {
            // AI가 질문하고 사용자가 답변하는 패턴 찾기
            if (messages[i-1].Role == MessageRoleType.Assistant && 
                messages[i].Role == MessageRoleType.User &&
                (messages[i-1].Message.Contains("?") || messages[i-1].Message.Contains("질문")))
            {
                questionsAndAnswers.Add(new QuestionAnswer
                {
                    Question = CleanMessage(messages[i-1].Message),
                    Answer = CleanMessage(messages[i].Message),
                    Feedback = ExtractFeedbackForAnswer(i)
                });
            }
        }
        
        Logger.LogInformation($"추출된 질문/답변 쌍: {questionsAndAnswers.Count}개");
    }

    // 메시지 정리 (불필요한 문구 제거)
    private string CleanMessage(string message)
    {
        // Markdown 제거 및 기본 정리
        var cleaned = message
            .Replace("**", "")
            .Replace("*", "")
            .Replace("#", "")
            .Trim();
            
        // 너무 긴 메시지는 요약
        if (cleaned.Length > 500)
        {
            cleaned = cleaned.Substring(0, 497) + "...";
        }
        
        return cleaned;
    }

    // 특정 답변에 대한 피드백 추출
    private string ExtractFeedbackForAnswer(int answerIndex)
    {
        // 답변 다음에 오는 AI 메시지에서 피드백 찾기
        if (answerIndex + 1 < messages.Count && 
            messages[answerIndex + 1].Role == MessageRoleType.Assistant)
        {
            var nextMessage = messages[answerIndex + 1].Message;
            
            // 피드백 키워드가 포함된 경우만 피드백으로 간주
            var feedbackKeywords = new[] { "좋습니다", "훌륭합니다", "개선", "보완", "추가로", "피드백" };
            
            if (feedbackKeywords.Any(keyword => nextMessage.Contains(keyword)) && 
                nextMessage.Length < 300)
            {
                return CleanMessage(nextMessage);
            }
        }
        
        return string.Empty;
    }

    // PDF 다운로드 메서드
    private async Task DownloadPdfReport()
    {
        try
        {
            isGeneratingPdf = true;
            StateHasChanged();

            // 실제 대화 데이터 기반으로 강점과 개선점 추출
            var (strengths, improvements) = ExtractStrengthsAndImprovements();

            var report = new InterviewReport
            {
                CandidateName = "지원자", // 추후 이력서에서 추출
                Position = "개발자", // 추후 채용공고에서 추출
                InterviewDate = DateTime.Now,
                QuestionsAndAnswers = questionsAndAnswers,
                OverallFeedback = finalFeedback,
                Strengths = strengths,
                ImprovementAreas = improvements,
                FitnessScore = ExtractFitnessScore(),
                FinalAssessment = finalFeedback
            };

            var pdfBytes = await ReportService.GeneratePdfReportAsync(report);
            var fileName = $"면접리포트_{DateTime.Now:yyyyMMdd_HHmmss}.pdf";
            
            await JSRuntime.InvokeVoidAsync("downloadFile", fileName, Convert.ToBase64String(pdfBytes));
            
            Logger.LogInformation("PDF 리포트 다운로드 완료");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "PDF 생성 중 오류 발생");
            await JSRuntime.InvokeVoidAsync("alert", "PDF 생성 중 오류가 발생했습니다: " + ex.Message);
        }
        finally
        {
            isGeneratingPdf = false;
            StateHasChanged();
        }
    }

    // 강점과 개선점 추출
    private (List<string> strengths, List<string> improvements) ExtractStrengthsAndImprovements()
    {
        var strengths = new List<string>();
        var improvements = new List<string>();

        // 종합 피드백에서 강점과 개선점 추출
        if (!string.IsNullOrEmpty(finalFeedback))
        {
            var lines = finalFeedback.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            
            bool inStrengths = false;
            bool inImprovements = false;
            
            foreach (var line in lines)
            {
                var cleanLine = line.Trim().Replace("*", "").Replace("-", "").Trim();
                
                if (cleanLine.Contains("강점") || cleanLine.Contains("잘한 점") || cleanLine.Contains("우수한"))
                {
                    inStrengths = true;
                    inImprovements = false;
                    continue;
                }
                
                if (cleanLine.Contains("개선") || cleanLine.Contains("부족한") || cleanLine.Contains("보완"))
                {
                    inStrengths = false;
                    inImprovements = true;
                    continue;
                }
                
                if (inStrengths && !string.IsNullOrWhiteSpace(cleanLine) && cleanLine.Length > 10)
                {
                    strengths.Add(cleanLine);
                }
                else if (inImprovements && !string.IsNullOrWhiteSpace(cleanLine) && cleanLine.Length > 10)
                {
                    improvements.Add(cleanLine);
                }
            }
        }

        // 기본값 설정
        if (strengths.Count == 0)
        {
            strengths.AddRange(new[] { "면접에 성실히 참여함", "질문에 적극적으로 답변함" });
        }
        
        if (improvements.Count == 0)
        {
            improvements.AddRange(new[] { "더 구체적인 경험 사례 제시 필요", "기술적 깊이 향상 권장" });
        }

        return (strengths, improvements);
    }

    // 적합성 점수 추출
    private int ExtractFitnessScore()
    {
        // 종합 피드백에서 점수 추출 시도
        if (!string.IsNullOrEmpty(finalFeedback))
        {
            var scoreMatches = System.Text.RegularExpressions.Regex.Matches(finalFeedback, @"(\d+)점|(\d+)/10|점수.*?(\d+)");
            if (scoreMatches.Count > 0)
            {
                foreach (System.Text.RegularExpressions.Match match in scoreMatches)
                {
                    for (int i = 1; i < match.Groups.Count; i++)
                    {
                        if (int.TryParse(match.Groups[i].Value, out int score) && score <= 10)
                        {
                            return score;
                        }
                    }
                }
            }
        }
        
        // 기본 점수 (질문/답변 수에 따라 결정)
        return Math.Min(8, 5 + questionsAndAnswers.Count);
    }

    // 테스트용 메서드들
    [JSInvokable]
    public void SetIsSendFlag(bool value)
    {
        isSend = value;
        StateHasChanged();
    }

    [JSInvokable]
    public bool GetIsSendFlag()
    {
        return isSend;
    }
}